import com.android.annotations.NonNull
import com.android.build.gradle.api.BaseVariantOutput
import com.android.build.gradle.internal.api.ReadOnlyObjectProvider
import com.android.build.gradle.internal.variant.LibraryVariantData
import com.android.builder.core.AndroidBuilder
import com.google.common.base.Charsets
import com.google.common.base.Strings
import com.google.common.collect.Lists
import com.google.common.collect.Maps
import com.google.common.io.Files
import org.gradle.api.model.ObjectFactory
import org.w3c.dom.Document
import org.w3c.dom.Element

import javax.xml.parsers.DocumentBuilderFactory
import java.nio.file.Path
import java.nio.file.Paths

import com.android.builder.model.AndroidProject
import org.apache.tools.ant.taskdefs.condition.Os
import org.gradle.api.DefaultTask
import org.gradle.api.GradleException
import org.gradle.api.Project
import org.gradle.api.Plugin
import org.gradle.api.Task
import org.gradle.api.file.CopySpec
import org.gradle.api.file.FileCollection
import org.gradle.api.tasks.Copy
import org.gradle.api.tasks.InputFiles
import org.gradle.api.tasks.OutputDirectory
import org.gradle.api.tasks.TaskAction
import org.gradle.api.tasks.bundling.Jar

import java.util.jar.JarEntry
import java.util.jar.JarFile
import com.android.build.gradle.api.LibraryVariant
import com.android.build.gradle.tasks.InvokeManifestMerger
import org.gradle.api.Project
import org.gradle.api.Task
import org.gradle.api.artifacts.ResolvedArtifact
import org.gradle.api.internal.artifacts.DefaultResolvedArtifact
import org.gradle.api.tasks.Copy
import org.gradle.jvm.tasks.Jar
import org.gradle.api.artifacts.Configuration
import com.android.build.gradle.LibraryExtension
import com.android.build.gradle.internal.api.LibraryVariantImpl
import com.android.build.gradle.BaseExtension
import com.android.build.gradle.api.AndroidSourceSet

buildscript {
    repositories {
        maven { url 'https://dl.google.com/dl/android/maven2/' }
        jcenter()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:3.0.1'

    }
}

apply plugin: FatFlutterLibraryPlugin

class FatFlutterLibraryPlugin implements Plugin<Project> {

    private Set<Project> resolvedProject = new HashSet<>()
    private Project project
    private def variant

    private Properties readPropertiesIfExist(File propertiesFile) {
        Properties result = new Properties()
        if (propertiesFile.exists()) {
            propertiesFile.withReader('UTF-8') { reader -> result.load(reader) }
        }
        return result
    }


    @Override
    void apply(Project project) {
        project.logger.error("****start")
        this.project = project
        checkAndroidPlugin()
        //解析 flutter plugin 找出所有的module依赖
//        File pluginsFile = new File(project.projectDir.parentFile.parentFile, '.flutter-plugins')
//        Properties plugins = readPropertiesIfExist(pluginsFile)
//        plugins.each { name, _ ->
//
//            project.logger.error("Plugin project :$name .")
//            def pluginProject = project.rootProject.findProject(":$name")
//            if (pluginProject != null) {
//                resolvedProject.add(pluginProject)
//            } else {
//                project.logger.error("Plugin project :$name not found. Please update settings.gradle.")
//            }
//        }
//        resolvedProject.add(project.rootProject.findProject(":${project.property("FLUTTER_MODULE_NAME")}"))

        resolvedProject.add(project.rootProject.findProject(":libarr2"))
        if (resolvedProject.size() < 1) {
            return
        }

        project.afterEvaluate {
            project.android.libraryVariants.all { variant ->
                this.variant = variant
                VariantProcessor processor = new VariantProcessor(this.project, this.variant)
                processor.addDepedences(resolvedProject)
                processor.process()
            }
        }
    }

    /**
     * 检查项目依赖是否存在
     */
    private void checkAndroidPlugin() {
        if (!project.plugins.hasPlugin('com.android.library')) {
            throw new ProjectConfigurationException('fat-aar-plugin must be applied in project that' +
                    ' has android library plugin!', null)
        }
    }
}

class VariantProcessor {
    private final Project project
    private final def variant
    private Set<Project> depProjects = new ArrayList<>()
    private Collection<DependenceProject> mAndroidLibraries = new ArrayList<>()


    VariantProcessor(Project project, def variant) {
        this.project = project
        this.variant = variant
    }

    void addDepedences(Set<Project> projectList) {
        depProjects.addAll(projectList)
    }

    void process() {
        project.logger.error("****process")

        for (Project depProject in depProjects) {
            DependenceProject archiveLibrary = new DependenceProject(project, depProject, variant)
            mAndroidLibraries.add(archiveLibrary)
        }

        processClassesAndJars()
//        processManifest()
        processResources()
        processRSources()
        processAssets()
        processJniLibs()

        String taskPath = 'pre' + variant.name.capitalize() + 'Build'
        Task prepareTask = project.tasks.findByPath(taskPath)
        if (prepareTask == null) {
            throw new RuntimeException("Can not find task ${taskPath}!")
        }
        taskPath = 'bundle' + variant.name.capitalize() + "Aar"
        project.logger.error("****$taskPath")
        Task bundleTask = project.tasks.findByPath(taskPath)
        if (bundleTask == null) {
            throw new RuntimeException("Can not find task ${taskPath}!")
        }
        mergeRClass(bundleTask)
    }

    /**
     * generate R.java
     */
    private void processRSources() {

        Task processResourcesTask = variant.getOutputs().first().getProcessResources()
        processResourcesTask.doLast {
            def libPackageName

            def androidExtension = project.extensions.getByName("android")
            androidExtension.sourceSets.all { sourceSet ->
                if (new File(sourceSet.getManifest().getSrcFile().path).exists()) {
                    def aarManifest = new XmlParser().parse(new File(sourceSet.getManifest().getSrcFile().path))
                    libPackageName =  aarManifest.@package
                }
            }

            for (archiveLibrary in mAndroidLibraries) {


                def manifestFile = archiveLibrary.manifest

                if (!manifestFile.exists()) {
                    continue
                }
                def aarManifest = new XmlParser().parse(manifestFile);
                def aarPackageName = aarManifest.@package
                String packagePath = aarPackageName.replace('.', '/')


                def rTxt = archiveLibrary.symbolFile

                def rMap = new ConfigObject()
                if (rTxt.exists()) {
                    rTxt.eachLine {
                        line ->
                            //noinspection GroovyUnusedAssignment
                            def (type, subclass, name, value) = line.tokenize(' ')
                            rMap[subclass].putAt(name, type)
                    }
                }

                def sb = "package $aarPackageName;" << '\n' << '\n'
                sb << 'public final class R {' << '\n'

                rMap.each {
                    subclass, values ->
                        sb << "  public static final class $subclass {" << '\n'
                        values.each {
                            name, type ->
                                sb << "    public static $type $name = ${libPackageName}.R.${subclass}.${name};" << '\n'
                        }
                        sb << "    }" << '\n'
                }

                sb << '}' << '\n'
                new File(processResourcesTask.getSourceOutputDir().path + "/" + packagePath + "/R.java").write(sb.toString())
            }
        }
    }

    /**
     * 合并所有的类文件
     */
    private void processClassesAndJars() {
        Task syncLibTask = project.tasks.findByPath("transformClassesAndResourcesWithSyncLibJarsFor" + variant.name.capitalize())
        syncLibTask.doLast {
            def dustDir = new File(resolveBundleDir().path + '/libs')
            for (androidLibrary in mAndroidLibraries) {
                def prefix = androidLibrary.name
                project.copy {
                    from(androidLibrary.classesJarFile)
                    into dustDir
                    rename { prefix + '_flated.jar' }
                }
                project.copy {
                    from(androidLibrary.localJars)
                    into dustDir
                }
            }
        }
    }


    File resolveBundleDir() {
        // do the trick getting assets task output
        Task mergeAssetsTask = variant.getMergeAssets()
        File assetsDir = mergeAssetsTask.getOutputDir()
        return assetsDir.getParentFile()
    }


    private void processResources() {
        String taskPath = 'generate' + variant.name.capitalize() + 'Resources'
        Task resourceGenTask = project.tasks.findByPath(taskPath)
        if (resourceGenTask == null) {
            throw new RuntimeException("Can not find task ${taskPath}!")
        }
        resourceGenTask.doFirst {
            for (archiveLibrary in mAndroidLibraries) {
                project.android.sourceSets."main".res.srcDir(archiveLibrary.resFolder)
                project.logger.error("****555${archiveLibrary.resFolder}")
            }
        }
    }

    /**
     * 合并asset目录
     */
    private void processAssets() {
        Task assetsTask = variant.getMergeAssets()
        assetsTask.doFirst {
            for (archiveLibrary in mAndroidLibraries) {
                // the source set here should be main or variant?
                project.android.sourceSets."main".assets.srcDirs += archiveLibrary.assetsFolder
            }
        }
    }

    /**
     * 合并jniLibs
     */
    private void processJniLibs() {
        String taskPath = 'merge' + variant.name.capitalize() + 'JniLibFolders'
        Task mergeJniLibsTask = project.tasks.findByPath(taskPath)
        if (mergeJniLibsTask == null) {
            throw new RuntimeException("Can not find task ${taskPath}!")
        }
        for (archiveLibrary in mAndroidLibraries) {
            mergeJniLibsTask.getInputs().dir(archiveLibrary.jniFolder)
        }
        mergeJniLibsTask.doFirst {
            for (archiveLibrary in mAndroidLibraries) {
                project.android.sourceSets."main".jniLibs.srcDir(archiveLibrary.jniFolder)
            }
        }
    }


    private void mergeRClass(Task bundleTask) {
        String taskPath = 'transformClassesAndResourcesWithSyncLibJarsFor' + variant.name.capitalize()
        Task syncLibTask = project.tasks.findByPath(taskPath)
        if (syncLibTask == null) {
            throw new RuntimeException("Can not find task ${taskPath}!")
        }

        // 原始jar包文件
        def classesJar = project.file(resolveBundleDir().path + '/classes.jar')
        String applicationId = variant.getApplicationId()
        String excludeRPath = applicationId.replace('.', '/')

        Task jarTask = project.tasks.create(name: 'transformJarTask' + variant.name.capitalize(), type: Jar) {
            from(project.buildDir.absolutePath + '/intermediates/classes/' + variant.name)
            exclude(excludeRPath + '/R.class', excludeRPath + '/R$*', 'META-INF/')
        }
        jarTask.onlyIf {
            File file = project.file(project.buildDir.absolutePath + '/intermediates/classes/' + variant.name)
            return file.exists()
        }
        jarTask.doLast {
            println 'transform jar ready'
            File file = new File(project.getBuildDir().absolutePath + '/libs/' + project.name + '.jar')
            if (file.exists()) {
                project.delete(classesJar)
                project.copy {
                    from(file)
                    into(resolveBundleDir())
                    rename(project.name + '.jar', 'classes.jar')
                }
            } else {
                println 'can not find transformProguradJar file '
            }
        }

        bundleTask.dependsOn jarTask
        jarTask.shouldRunAfter(syncLibTask)
    }


    private void processManifest() {
        project.logger.error("****processManifest")
        Class invokeManifestTaskClazz = null
        String className = 'com.android.build.gradle.tasks.InvokeManifestMerger'
        try {
            invokeManifestTaskClazz = Class.forName(className)

        } catch (ClassNotFoundException ignored) {
        }
        if (invokeManifestTaskClazz == null) {
            throw new RuntimeException("Can not find class ${className}!")
        }
        Task processManifestTask = variant.getOutputs().first().getProcessManifest()
        def manifestOutput = project.file(project.buildDir.path + '/intermediates/fat-aar/' + variant.dirName)
        File manifestOutputBackup = project.file(processManifestTask.getManifestOutputDirectory().absolutePath + '/AndroidManifest.xml')
        project.logger.error("****processManifest00:$manifestOutputBackup")

        processManifestTask.setManifestOutputDirectory(manifestOutput)

        File mainManifestFile = new File(manifestOutput.absolutePath + '/AndroidManifest.xml')
        mainManifestFile.deleteOnExit()
        manifestOutput.mkdirs()
        mainManifestFile.createNewFile()
        processManifestTask.doLast {
            mainManifestFile.write(manifestOutputBackup.text)
        }
        InvokeManifestMerger manifestsMergeTask = project.tasks.create('merge' + variant.name.capitalize() + 'Manifest', invokeManifestTaskClazz)
        manifestsMergeTask.setVariantName(variant.name)
        manifestsMergeTask.setMainManifestFile(mainManifestFile)
        List<File> list = new ArrayList<>()
        for (archiveLibrary in mAndroidLibraries) {
            def file = archiveLibrary.getManifest()
            project.logger.error("****processManifest11:$file")
            list.add(file)
        }
        manifestsMergeTask.setSecondaryManifestFiles(list)
        manifestsMergeTask.setOutputFile(manifestOutputBackup)
        manifestsMergeTask.dependsOn processManifestTask
        manifestsMergeTask.doFirst {
            project.logger.error("****processManifest22")
            List<File> existFiles = new ArrayList<>()
            manifestsMergeTask.getSecondaryManifestFiles().each {
                    project.logger.error("****processManifest33:$it")
                if (it.exists()) {
                    existFiles.add(it)
                }
            }
            manifestsMergeTask.setSecondaryManifestFiles(existFiles)
        }
        processManifestTask.finalizedBy manifestsMergeTask
    }


}

class DependenceProject {
    private final Project mainProject
    private final Project depProject
    private final def variant

    DependenceProject(Project mainProject, Project depProject, def variant) {
        this.depProject = depProject
        this.mainProject = mainProject
        this.variant = variant
    }


    String getGroup() {
        return mainProject.getName()
    }

    String getName() {
        return depProject.getName()
    }

    File getAidlFolder() {
        return new File(depProject.buildDir.path + "/intermediates/bundles/" + variant.name + "/aidl")
    }

    File getAssetsFolder() {
        println depProject.buildDir.path + "/intermediates/bundles/" + variant.name + "/assets"
        return new File(depProject.buildDir.path + "/intermediates/bundles/" + variant.name + "/assets")
    }

    File getClassesJarFile() {
        return new File(depProject.buildDir.path + "/intermediates/intermediate-jars/" + variant.name + "/classes.jar")
    }

    Collection<File> getLocalJars() {
        List<File> localJars = new ArrayList<>()
        File[] jarList = new File(depProject.buildDir.path + "/intermediates/bundles/" + variant.name + "/libs").listFiles()
        if (jarList != null) {
            for (File jars : jarList) {
                if (jars.isFile() && jars.getName().endsWith(".jar")) {
                    localJars.add(jars)
                }
            }
        }

        return localJars
    }

    File getJniFolder() {
        return new File(depProject.buildDir.path + "/intermediates/bundles/" + variant.name + "/jni")
    }


    File getResFolder() {
        return new File(depProject.buildDir.path + "/intermediates/bundles/" + variant.name + "/res")
    }

    File getManifest() {
        return new File(depProject.buildDir.path + "/intermediates/manifests/aapt/" + variant.name + "/AndroidManifest.xml")
    }


    File getSymbolFile() {
        return new File(depProject.buildDir.path + "/intermediates/bundles/release/", "R.txt")
    }

    String getPackageName() {
        String packageName = null
        File manifestFile = getManifest()
        if (manifestFile.exists()) {
            try {
                DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance()
                Document doc = dbf.newDocumentBuilder().parse(manifestFile)
                Element element = doc.getDocumentElement()
                packageName = element.getAttribute("package")
            } catch (Exception ignored) {
            }
        }
        return packageName
    }
}